#!/usr/bin/env python3
# _*_ coding: utf-8 _*_

# Copyright (C) 2022-present naheel-azawy
# Copyright (C) 2020 Piotr Miller & Contributors
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# This script is based on sgtk-menu by Piotr Miller.
# A newer version by him can be found there
# https://github.com/nwg-piotr/nwg-drawer
#
# Old header:
#
# This script creates a GNOME-like application grid out of .desktop files content,
# optionally prepended with a menu created out of user-defined template.
#
# Author: Piotr Miller
# Copyright (c) 2020 Piotr Miller & Contributors
# e-mail: nwg.piotr@gmail.com
# Website: http://nwg.pl
# Project: https://github.com/nwg-piotr/sgtk-menu
# License: GPL3

import os
import tempfile
import fcntl
import sys
import subprocess
import argparse
import locale
import json
from dataclasses import dataclass

import warnings
warnings.filterwarnings("ignore")

import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gdk, GdkPixbuf


NAME = "application-launcher"

CSS = b"""
#searchbox {
    background: none;
    border-color: #999;
    color: #ccc
}
#button {
    background: none;
    border-style: none;
    box-shadow: none;
    color: #999;
}
#button:hover {
    background-color: rgba(255, 255, 255, 0.1);
    color: #eee
}
#button:focus {
    background-color: rgba(255, 255, 255, 0.2);
    color: #eee
}
#separator {
    background-color: rgba(200, 200, 200, 0.7);
    margin: 10px;
}
"""

@dataclass
class Geometry:
    x: int
    y: int
    w: int
    h: int

def display_geometry(win):
    """
    Returns geometry of currently focused display
    :return: (x, y, width, height)
    """
    screen = win.get_screen()
    try:
        active = screen.get_active_window() # FIXME: depricated
        if active:
            display_number = screen.get_monitor_at_window(active)
        else:
            # Could not detect active window; use first monitor
            display_number = 0
        rectangle = screen.get_monitor_geometry(display_number)
        return Geometry(rectangle.x, rectangle.y, rectangle.width, rectangle.height)
    except:
        return None


def get_locale_string(forced_lang=None):
    if forced_lang:
        language = forced_lang.split("_")[0]
    else:
        language = locale.getlocale()[0] or "en_US"
    lang = language.split("_")[0]
    if lang:
        return '[{}]'.format(lang)
    else:
        return None


def data_dirs():
    paths = [os.path.expanduser('~/.local/share'), "/usr/share", "/usr/local/share"]
    if "XDG_DATA_DIRS" in os.environ:
        dirs = os.environ["XDG_DATA_DIRS"]
        if dirs:
            dirs = dirs.split(":")
            for d in dirs:
                while d.endswith("/"):
                    d = d[:-1]
                if d not in paths:
                    paths.append(d)
    return paths


def load_json(path):
    try:
        with open(path, 'r') as f:
            return json.load(f)
    except Exception as e:
        return {}


def save_json(src_dict, path):
    with open(path, 'w') as f:
        json.dump(src_dict, f, indent=4)


# List to hold AppButtons for favourites
all_favs = []
# Lists to hold AppBoxes for apps found in .desktop files
all_apps = []

localized_names_dictionary = {}  # name => translated name
locale_str = ''

win = None  # overlay window
geometry = None
args = None
all_items_list = []  # list of all DesktopMenuItem objects assigned to a .desktop entry
all_copies_list = []  # list of copies of above used while searching (not assigned to a submenu!)
menu_items_list = []  # created / updated with menu.get_children()
filtered_items_list = []  # used in the search method

# If we need to cheat_sway, we only add first args.t entries to all_copies list, but we need them all for searching!
missing_copies_list = []

if "XDG_CACHE_HOME" in os.environ:
    cache_dir = os.environ["XDG_CACHE_HOME"]
else:
    cache_dir = os.path.join(os.path.expanduser('~/.cache'))
if not os.path.exists(cache_dir):
    os.makedirs(cache_dir)

# We track clicks in the same cache file
cache_file_desktops = os.path.join(cache_dir, NAME + ".json")
cache_file = os.path.join(cache_dir, NAME + "-count.json")
cache = None
sorted_cache = None


def main():
    # exit if already running, thanks to Slava V at https://stackoverflow.com/a/384493/4040598
    pid_file = os.path.join(tempfile.gettempdir(), NAME + ".pid")
    fp = open(pid_file, 'w')
    try:
        fcntl.lockf(fp, fcntl.LOCK_EX | fcntl.LOCK_NB)
    except IOError:
        subprocess.run("pkill -f " + NAME, shell=True)
        sys.exit(2)

    parser = argparse.ArgumentParser(description="Application launcher")

    parser.add_argument('-d', type=str, default="", help="use alternate folder list (: delimited) for .Desktop files")
    parser.add_argument('-c', type=int, default=6,  help="number of grid columns (default: 6)")
    parser.add_argument('-t', type=int, default=30, help="top margin width in px (default: 30)")
    parser.add_argument('-b', type=int, default=15, help="bottom margin width in px (default: 15)")

    favourites = parser.add_mutually_exclusive_group()
    favourites.add_argument("-f",  action="store_true", help="prepend 1 row of favourites (most used items)")
    favourites.add_argument('-fn', default=0, type=int, help="prepend <FN> rows of favourites")

    parser.add_argument("-u",   action="store_true",      help="update cache")
    parser.add_argument("-l",   type=str,                 help="force language (e.g. \"de\" for German)")
    parser.add_argument("-s",   type=int,   default=72,   help="menu icon size (min: 16, max: 96, default: 72)")
    parser.add_argument("-o",   type=float, default=0.9,  help="overlay opacity (min: 0.0, max: 1.0, default: 0.9)")
    parser.add_argument("-css", type=str,   default=None, help="use alternative style sheet instead of the default")
    global args
    args = parser.parse_args()

    if args.s < 16:
        args.s = 16
    elif args.s > 96:
        args.s = 96

    screen = Gdk.Screen.get_default()
    provider = Gtk.CssProvider()
    try:
        if args.css:
            provider.load_from_path(args.css)
        else:
            provider.load_from_data(CSS)
        Gtk.StyleContext.add_provider_for_screen(
            screen, provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
    except Exception as e:
        print(e)

    # cache stores number of clicks on each item
    global cache
    cache = load_json(cache_file)

    if not cache:
        save_json(cache, cache_file)
    global sorted_cache
    sorted_cache = sorted(cache.items(), reverse=True, key=lambda x: x[1])

    global locale_str
    locale_str = get_locale_string(args.l)

    screen = Gdk.Screen.get_default()
    provider = Gtk.CssProvider()
    style_context = Gtk.StyleContext()
    style_context.add_provider_for_screen(
        screen, provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
    )

    # find all .desktop entries, create AppButton class instances;
    list_entries()

    # find favourites in the list above
    if args.f or args.fn > 0:
        list_favs()

    # Overlay window
    global win
    win = MainWindow()

    global geometry
    geometry = None
    # If we're not on sway neither i3, this won't return values until the window actually shows up.
    # Let's try as many times as needed. The retries int protects from an infinite loop.
    retries = 0
    while not geometry:
        geometry = display_geometry(win)
        retries += 1
        if retries > 10:
            print("\nFailed to get the current screen geometry, exiting...\n")
            sys.exit(2)

    if geometry.w > geometry.h:
        search_width = geometry.w / 3
    else:
        search_width = geometry.w * .9
    win.search_box.set_size_request(search_width, 0)
    if all_favs:
        win.sep1.set_size_request(search_width, 1)

    win.show_all()
    # If done inside the constructor on Openbox, stops the window from grabbing focus!
    win.set_skip_taskbar_hint(True)

    # Necessary in FVWM, otherwise it always gets on screen 0
    win.move(geometry.x, geometry.y)

    Gtk.main()


class MainWindow(Gtk.Window):
    def __init__(self):
        global args
        Gtk.Window.__init__(self)

        self.fullscreen()
        self.set_skip_pager_hint(True)

        self.set_title('Applications')
        self.set_role(NAME)

        self.connect("destroy", Gtk.main_quit)
        self.connect("key-release-event", self.search_items)
        self.connect("button-press-event", Gtk.main_quit)

        self.search_phrase = ''
        self.grid_favs = None

        # Credits for transparency go to KurtJacobson:
        # https://gist.github.com/KurtJacobson/374c8cb83aee4851d39981b9c7e2c22c
        screen = self.get_screen()
        visual = screen.get_rgba_visual()
        if visual and screen.is_composited():
            self.set_visual(visual)
        self.set_app_paintable(True)

        outer_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)

        hbox = Gtk.HBox()
        self.search_box = Gtk.SearchEntry()
        self.search_box.set_property("name", "searchbox")
        self.search_box.set_text('Type to search')
        self.search_box.set_sensitive(False)
        hbox.pack_start(self.search_box, True, False, 0)
        outer_box.pack_start(hbox, False, False, args.t)

        vbox = Gtk.VBox()
        vbox.set_spacing(15)

        if all_favs:
            hbox0 = Gtk.HBox()
            self.grid_favs = ApplicationGrid(all_favs, columns=args.c)
            hbox0.pack_start(self.grid_favs, True, False, 0)
            vbox.pack_start(hbox0, False, False, 0)

            self.sep1 = Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)
            self.sep1.set_property("name", "separator")
            hbox_s = Gtk.HBox()
            hbox_s.pack_start(self.sep1, True, False, 0)
            vbox.pack_start(hbox_s, False, True, 20)
        else:
            self.grid_favs = None
            self.sep1 = None

        self.hbox1 = Gtk.HBox()
        self.grid_apps = ApplicationGrid(all_apps, columns=args.c)
        self.hbox1.pack_start(self.grid_apps, True, False, 0)
        vbox.pack_start(self.hbox1, False, False, 0)

        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_propagate_natural_height(True)
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.ALWAYS)
        scrolled_window.add(vbox)

        outer_box.pack_start(scrolled_window, True, True, 0)

        self.add(outer_box)

    def search_items(self, item, event):
        global filtered_items_list
        if event.type == Gdk.EventType.KEY_RELEASE:
            update = False
            # search box only accepts alphanumeric characters, space and backspace
            if event.string and event.string.isalnum() or event.string == ' ':
                if self.grid_favs:
                    self.grid_favs.hide()
                    self.sep1.get_parent().hide()
                update = True
                self.search_phrase += event.string
                self.search_box.set_text(self.search_phrase)

            elif event.keyval == 65288:  # backspace
                update = True
                self.search_phrase = self.search_phrase[:-1]
                self.search_box.set_text(self.search_phrase)

            elif event.keyval == 65307:  # Escape
                if self.search_phrase:
                    self.search_phrase = ""
                    update = True
                else:
                    Gtk.main_quit()

            if not self.search_phrase:
                filtered_items_list = []
                if self.grid_favs:
                    self.grid_favs.show()
                    self.sep1.get_parent().show()

            if update:
                if len(self.search_phrase) > 0:
                    filtered_items_list = []
                    for item in all_apps:
                        # We'll search the entry name and the first element of its command (to skip arguments)
                        if self.search_phrase.upper() in item.name.upper() or self.search_phrase.upper() in \
                                item.exec.split()[0].upper():
                            # avoid adding twice
                            found = False
                            for i in filtered_items_list:
                                if i.name == item.name:
                                    found = True
                            if not found:
                                filtered_items_list.append(item)
                    self.grid_apps.update(filtered_items_list)
                else:
                    self.grid_apps.update(all_apps)

            if len(self.search_phrase) == 0:
                self.search_box.set_text('Type to search')

            if len(filtered_items_list) == 1:
                filtered_items_list[0].button.set_property("has-focus", True)

        return True

    def die(self, *args):
        Gtk.main_quit()


def desktop_parse_bool(line):
    try:
        return line.split('=')[1].strip().lower() == "true"
    except:
        return False

def list_entries():
    if os.path.exists(cache_file_desktops) and not args.u:
        try:
            with open(cache_file_desktops, "r") as f:
                for o in json.load(f):
                    all_apps.append(AppBox.from_dict(o))
                return
        except:
            print("Failed reading cache")
            pass

    apps = []
    paths = ([os.path.join(p, 'applications') for p in data_dirs()])
    if args.d != "":
        if ":" not in args.d:
            paths=[args.d]
        else:
            paths=args.d.split(':')
    for path in paths:
        if os.path.exists(path):
            for f in os.listdir(path):
                app = AppBox()
                try:
                    with open(os.path.join(path, f)) as d:
                        lines = d.readlines()
                        read_me = True

                        for line in lines:
                            if line.startswith("["):
                                read_me = line.strip() == "[Desktop Entry]"
                                continue
                            if read_me:
                                loc_name = 'Name{}='.format(locale_str)

                                if line.startswith('NoDisplay='):
                                    if desktop_parse_bool(line):
                                        app = None
                                        break
                                    continue

                                if line.startswith('Name='):
                                    app.name = line.split('=')[1].strip()
                                    continue

                                if line.startswith(loc_name):
                                    app.name = line.split('=')[1].strip()
                                    continue

                                loc_comment = 'Comment{}='.format(locale_str)

                                if line.startswith('Comment='):
                                    app.comment = line.split('=')[1].strip()
                                    continue

                                if line.startswith(loc_comment):
                                    app.comment = line.split('=')[1].strip()
                                    continue

                                if line.startswith('Exec='):
                                    cmd = line.split('=')[1:]
                                    c = '='.join(cmd)
                                    app.exec = c.strip()
                                    if '%' in app.exec:
                                        app.exec = app.exec.split('%')[0].strip()
                                    continue

                                if line.startswith('Icon='):
                                    app.icon = line.split('=')[1].strip()

                                if line.startswith('Terminal='):
                                    app.terminal = desktop_parse_bool(line)

                        if app and app.name and app.exec and app.icon:
                            # avoid adding twice
                            found = False
                            for item in apps:
                                if item.name == app.name and item.exec == app.exec:
                                    found = True
                            if not found:
                                apps.append(app)

                except Exception as e:
                    print(e)

    apps = sorted(apps, key=lambda x: x.name.upper())
    for app in apps:
        all_apps.append(app)

    with open(cache_file_desktops, "w") as f:
        json.dump(apps, f, indent=4, default=lambda o: o.__dict__)


def list_favs():
    # Prepend favourite items (-f or -fn argument used)
    favs_number = 0
    if args.f:
        favs_number = args.c
    elif args.fn:
        favs_number = args.fn * args.c
    if favs_number > 0:
        global sorted_cache
        if len(sorted_cache) < favs_number:
            favs_number = len(sorted_cache)

        to_prepend = []
        for i in range(favs_number):
            fav_exec = sorted_cache[i][0]
            for button in all_apps:
                if button.exec == fav_exec and button not in to_prepend:
                    to_prepend.append(button)
                    break  # stop searching, there may be duplicates on the list
        for button in to_prepend:
            all_favs.append(AppBox(button.name, button.exec, button.icon, button.comment))

@dataclass
class AppBox:
    name:     str          = ""
    exec:     str          = ""
    icon:     str          = ""
    comment:  str          = ""
    terminal: bool         = False
    button:   Gtk.Button   = None
    evbox:    Gtk.EventBox = None

    def from_dict(json_dict):
        return AppBox(
            json_dict["name"],
            json_dict["exec"],
            json_dict["icon"],
            json_dict["comment"],
            json_dict["terminal"]
        )

    def box(self):
        if self.evbox is not None:
            return self.evbox

        #if len(name) > 25:
        #    name = "{}...".format(name[:22])
        self.button = Gtk.Button()
        self.button.set_property("name", "button")
        self.button.set_always_show_image(True)
        self.button.set_image(app_image(self.icon))
        self.button.set_image_position(Gtk.PositionType.TOP)
        self.button.set_label(self.name)
        self.button.set_tooltip_text(self.comment if self.comment else self.name)
        self.button.connect("clicked", launch, self)

        box = Gtk.Box()
        box.pack_start(self.button, True, True, 5)

        self.evbox = Gtk.EventBox()
        self.evbox.add(box)
        return self.evbox



def app_image(icon):
    """
    Creates a Gtk.Image instance
    :param icon: sys icon name or .svg / png path
    :return: Gtk.Image
    """
    icon_theme = Gtk.IconTheme.get_default()
    try:
        if icon.startswith('/'):
            pixbuf = GdkPixbuf.Pixbuf.new_from_file_at_size(icon, args.s, args.s)
        else:
            if icon.endswith('.svg') or icon.endswith('.png'):
                icon = icon.split('.')[0]
            pixbuf = icon_theme.load_icon(icon, args.s, Gtk.IconLookupFlags.FORCE_SIZE)
    except:
        pixbuf = icon_theme.load_icon("application-x-executable", args.s, Gtk.IconLookupFlags.FORCE_SIZE)
    return Gtk.Image.new_from_pixbuf(pixbuf)


class ApplicationGrid(Gtk.Grid): # TODO: use FlowBox
    def __init__(self, items_list, columns=6):
        super().__init__()
        self.set_column_spacing(25)
        self.set_row_spacing(15)
        self.set_row_homogeneous(True)
        self.set_column_homogeneous(True)
        self.items_list = items_list
        self.columns = columns
        col, row = 0, 0
        for item in self.items_list:
            if not item.box().get_parent():  # check if not yet attached (e.g. in favourites)
                self.attach(item.box(), col, row, 1, 1)
                if col < self.columns - 1:
                    col += 1
                else:
                    col = 0
                    row += 1

    def update(self, items_list):
        for item in all_favs:
            item.button.unset_state_flags(Gtk.StateFlags.PRELIGHT)
            item.button.unset_state_flags(Gtk.StateFlags.SELECTED)
            item.button.unset_state_flags(Gtk.StateFlags.FOCUSED)
        for item in self.get_children():
            self.remove(item)
            # indicates if the widget has a mouse pointer over it
            item.get_children()[0].unset_state_flags(Gtk.StateFlags.PRELIGHT)
        col, row = 0, 0
        for item in items_list:
            if not item.box().get_parent():  # check if not yet attached (e.g. in favourites)
                self.attach(item.box(), col, row, 1, 1)
                if col < self.columns - 1:
                    col += 1
                else:
                    col = 0
                    row += 1


def launch(btn, item, no_cache=False):
    command = item.exec
    if item.terminal:
        command = "$TERMINAL -e " + command # TODO: make it more portable
    if not no_cache:
        # save command and increased clicks counter to the cache file; we won't cache items from the user-defined menu
        if command not in cache:
            cache[command] = 1
        else:
            cache[command] += 1
        save_json(cache, cache_file)
    # run the command an quit
    subprocess.Popen('exec {}'.format(command), shell=True)
    Gtk.main_quit()


if __name__ == "__main__":
    main()
