#!/bin/sh

SELF="$0"
OP_FILE=/tmp/fmz-op
HIDDEN_FILE=/tmp/fmz-hidden
SORT_FILE=/tmp/fmz-sort

CD=
ID= ; W= ; H=
PV= ; PV_WIN= ; USE_STPV=

bindings="ctrl-g:$cmd_refresh"
bookmarks="$HOME"

cmd_reload="reload('$SELF' --eval list)"
cmd_open="accept-non-empty"
cmd_updir="abort+execute(echo ..)"
cmd_menu="execute('$SELF' --eval menu {})+$cmd_reload"
cmd_copy="execute-silent('$SELF' --eval copy {} &)"
cmd_move="execute-silent('$SELF' --eval move {} &)"
cmd_paste="execute-silent('$SELF' --eval paste)+$cmd_reload"
cmd_rename="execute('$SELF' --eval rename {})+$cmd_reload"
cmd_delete="execute('$SELF' --eval delete {})+$cmd_reload"
cmd_goto="abort+execute('$SELF' --eval goto {})"
cmd_refresh="abort+execute(echo .)"
cmd_tog_hidden="execute('$SELF' --eval tog_hidden)+$cmd_reload"

bind() {
    key="$1"
    cmd="$2"
    bindings="$bindings,$key:$cmd"
}

bookmark() {
    [ -d "$1" ] && {
        bookmarks="$bookmarks:$1"
    }
}

bind right  "$cmd_open"
bind left   "$cmd_updir"
bind alt-x  "$cmd_menu"
bind ctrl-c "$cmd_copy"
bind ctrl-x "$cmd_move"
bind ctrl-v "$cmd_paste"
bind f2     "$cmd_rename"
bind del    "$cmd_delete"
bind ctrl-l "$cmd_goto"
bind ctrl-r "$cmd_refresh"
bind f5     "$cmd_refresh"
bind ctrl-h "$cmd_tog_hidden"

bookmark ~/Documents
bookmark ~/Pictures
bookmark ~/Videos
bookmark ~/Music
bookmark ~/Downloads
bookmark ~/Projects

# TODO: source rc script here later

exists() {
    command -v "$1" >/dev/null
}

menu_interface() {
    if exists dmenu; then
        # dmenu is the only properly functioning menu for now
        list=$(cat)
        count=$(echo "$list" | wc -l)
        if [ "$count" -gt 3 ]; then
            echo "$list" | dmenu -l "$count" -i "$@"
        else
            echo "$list" | dmenu -i "$@"
        fi
    elif false; then
        # fails for unknown inputs.
        # keeping in case a workaround is found later
        prompt=
        [ "$1" = -p ] && prompt="$2> " && shift 2
        if [ "$prompt" ]; then
            fzf --reverse --prompt "$prompt" "$@"
        else
            fzf "$@"
        fi
    else
        if [ "$1" = -p ]; then
            echo "$2:"
            shift 2
        fi
        list=$(cat)
        [ "$list" ] && {
            list=$(echo "$list" | nl)
            echo "$list" >/dev/tty
        }
        printf '> ' >/dev/tty
        read -r inp </dev/tty
        sel=$(echo "$list" |
                  grep -i "$inp" |
                  awk '{for (i=2; i<=NF; i++) print $i}')
        [ "$sel" ] || sel="$inp"
        echo "$sel"
        # FIXME: output here is not captured
    fi
}

menu() {
    res=$({
             echo 'Copy'
             echo 'Move'
             echo 'Paste'
             echo 'Rename'
             echo 'Delete'
             echo 'New folder'
             echo 'New file'
             echo 'Sort normally'
             echo 'Sort by time'
             echo 'Sort by size'
         } | menu_interface -p "$1")
    case "$res" in
        'Copy')          copy   "$1" ;;
        'Move')          move   "$1" ;;
        'Paste')         paste       ;;
        'Rename')        rename "$1" ;;
        'Delete')        delete "$1" ;;
        'New folder')    mkfolder    ;;
        'New file')      mkfile      ;;
        'Sort normally') lssort ''   ;;
        'Sort by time')  lssort time ;;
        'Sort by size')  lssort size ;;
    esac
}

copy() {
    f=$(realpath "$1")
    printf '%s' "$f" | xclip -i -selection clipboard
    {
        echo "copy"
        echo "$f"
    } > "$OP_FILE"
}

move() {
    f=$(realpath "$1")
    printf '%s' "$f" | xclip -i -selection clipboard
    {
        echo "move"
        echo "$f"
    } > "$OP_FILE"
}

paste() {
    load=$(cat "$OP_FILE")
    mode=$(echo "$load" | sed -n '1p')
    list=$(echo "$load" | sed '1d')
    f=$(echo "$list" | head -n 1)

    if exists cp-p; then
        srcf=$(mktemp)
        echo "$list" > "$srcf"
        case "$mode" in
            copy)
                cp-p --new-line --backup=numbered -a -F "$srcf" . ;;
            move)
                mv-p --new-line --backup=numbered -F "$srcf" . ;;
        esac
        rm -f "$srcf"
    else
        case "$mode" in
            copy) cp "$f" .;;
            move) mv "$f" .;;
        esac
    fi
}

rename() {
    name=$(echo | menu_interface -p "Rename $1 to...")
    [ "$name" ] && {
        if [ -e "$name" ]; then
            echo "$name already exists"
        else
            mv "$1" "$name"
        fi
    }
}

delete() {
    echo "$@"
    ans=$(printf 'Trash\nDelete permanently\nCancel\n' |
              menu_interface)
    case "$ans" in
        Trash)
            # move current file or selected files to trash folder
            # using trash-cli (https://github.com/andreafrancia/trash-cli)
            gio trash "$@" || trash-put "$@" ;;
        Delete*)
            rm -rf "$@" ;;
    esac
}

mkfolder() {
    name=$(echo | menu_interface -p 'Folder name')
    if [ -e "$name" ]; then
       echo "$name already exists"
    else
        mkdir -p "$name"
    fi
}

mkfile() {
    name=$(echo | menu_interface -p 'File name')
    if [ -e "$name" ]; then
       echo "$name already exists"
    else
        touch "$name"
    fi
}

goto() {
    res=$({
             realpath .
             echo "$bookmarks" | tr ':' '\n'
             lsblk -rpo "name,type,fsavail,fssize,mountpoint,label" |
                 awk '
                   $6 != "" { $6 = $6" " };
                   ($2=="part"||$2=="lvm") && $5 != "" {
                     printf "Partition %s#%s#%s#(%s/%s)\n", $5, $1, $6, $3, $4
                   }' |
                 tac | column -t -s'#'
         } | menu_interface)

    case "$res" in
        Partition*)
            res=$(echo "$res" | cut -d ' ' -f2) ;;
        *)
            [ -d "$res" ] || res="$HOME/$res"
            [ -d "$res" ] || res=''
    esac

    if [ -d "$res" ]; then
        echo "$res"
    else
        pwd # stay the same dir
    fi
}

tog_hidden() {
    if [ -f "$HIDDEN_FILE" ]; then
        rm "$HIDDEN_FILE"
    else
        touch "$HIDDEN_FILE"
    fi
}

lssort() {
    if [ "$1" ]; then
        echo "$1" > "$SORT_FILE"
    else
        rm -f "$SORT_FILE"
    fi
}

list() {
    cmd="echo ..; "
    cmd="$cmd command ls -1 --group-directories-first"
    cmd="$cmd --group-directories-first"
    cmd="$cmd --color=always"
    if [ -f "$HIDDEN_FILE" ]; then
        cmd="$cmd -A"
    fi
    if [ -f "$SORT_FILE" ]; then
        sort=$(cat "$SORT_FILE")
        [ "$sort" ] &&
            cmd="$cmd --sort=$sort"
    fi
    eval "$cmd"
}

header() {
    . /usr/share/git/completion/git-prompt.sh
    GIT_PS1_SHOWDIRTYSTATE=auto
    GIT_PS1_SHOWSTASHSTATE=auto
    GIT_PS1_SHOWUNTRACKEDFILES=auto
    GIT_PS1_SHOWUPSTREAM=auto
    git=$(__git_ps1 " (%s)") || true
    dev=$(findmnt -T . -no "source,avail,size,label" |
              awk '$4 != "" {$4 = $4" "};
                   {printf "%s%s (%s/%s)", $4, $1, $2, $3}')
    printf '\033[1m\033[34m%s\033[1m: \033[37m%s\033[1m\033[32m%s\033[0m\033[0m' \
           "$PWD" "$dev" "$git"
}

preview() {
    f="$1"
    if [ -d "$f" ]; then
        ls --color=always --group-directories-first "$f"
    else
        cat "$f" 2>/dev/null ||
            file "$f"
    fi
}

# for fzf preview
SHELL=bash
exists dash && SHELL=dash
fuzzy() {
    if [ "$USE_STPV" ]; then
        PV_CMD="'$SELF' --eval \"stpv {} $PV\""
    else
        PV_CMD="'$SELF' --eval \"preview {}\""
    fi
    fzf --ansi --reverse --multi   \
        --preview-window "$PV_WIN" \
        --preview "$PV_CMD"        \
        --header "$(header)"       \
        --bind "$bindings"
}

update_term_size() {
    W=$(tput cols)
    H=$(tput lines)
    COLS=$(tput cols)
    LINS=$(tput lines)
    if [ "$W" -gt $((H*3)) ] || [ "$W" -gt 169 ]; then
        PV_WIN='right:50%'
        X=$((COLS / 2 + 2))
        Y=1
        W=$((((COLS - 1) / 2) - 2))
        H=$((LINS - 2))
    else
        PV_WIN='down:50%'
        X=1
        Y=$((LINS / 2 + 2))
        W=$((COLS - 2))
        H=$((((LINS - 1) / 2) - 2))
    fi
    PV="$W $H $X $Y $ID"
}

doit() {
    ID=$$
    exists stpv && USE_STPV=1
    update_term_size
    [ "$USE_STPV" ] &&
        stpvimg --listen $ID 2>/dev/null &

    res=init
    while [ "$res" ]; do
        res=$(list | fuzzy)
        if [ "$res" ]; then
            if [ -f "$res" ]; then
                open "$res"
            elif [ -d "$res" ]; then
                cd "$res" || return 1
            fi
        fi
        update_term_size
    done

    [ "$USE_STPV" ] &&
        stpvimg --end $ID

    if [ -f "$CD" ]; then
        pwd > "$CD"
    else
        pwd
    fi
}

main() {
    case "$1" in
        --cd)
            CD="$2"
            shift 2
    esac

    case "$1" in
        --eval) shift; eval "$@" ;;
        *)             doit
    esac
}

main "$@"
