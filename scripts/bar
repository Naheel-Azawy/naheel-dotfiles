#!/bin/python3

# TODO: turn items to shell script functions
# python opens a shell instance, source the items script,
# and call them whenever needed.
# this also can turn it into something that everyone can use.

import sh
import os
import sys
import json
import re
import time
import datetime
import asyncio
import threading
import subprocess
import socket
import signal
import importlib

def import_path(path):
    # https://stackoverflow.com/a/56090741/3825872
    path = os.path.dirname(os.path.realpath(__file__)) + "/" + path
    module_name = os.path.basename(path).replace('-', '_')
    spec = importlib.util.spec_from_loader(
        module_name,
        importlib.machinery.SourceFileLoader(module_name, path)
    )
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    sys.modules[module_name] = module
    return module

wsw    = import_path("wsw")
xrandr = import_path("xrandr-parse")

try:
    # sudo pip3 install python-bidi arabic-reshaper
    import bidi.algorithm
    import arabic_reshaper
    use_arabic = True
except:
    use_arabic = False

background = '#99000000'
foreground = '#ffffff'

default_items = "start workspaces add program | clock | systray pray weather temperature wifi battery power"

port_file = "/tmp/.nbarport"

argv = sys.argv
HOME = os.getenv("HOME")
WINDOW_MANAGER = os.getenv("WINDOW_MANAGER")

# example: WM(lambda s: print(s)).run()
class WM:
    def __init__(self, callback):
        wm = WINDOW_MANAGER
        self.impl = wsw.init(output="lemonbar", onchange=callback)
        self.title = None # to be set by bar.program()
        # names to be picked for new workspaces
        self.nice_workspaces = list(range(1, 10)) + [0]
        self.nice_workspaces = list(map(lambda i: str(i), self.nice_workspaces))

    async def run(self):
        count = 0
        while count < 10:
            try:
                await asyncio.to_thread(self.impl.run)
                break
            except Exception:
                # in case the bar started before the window manager
                await asyncio.sleep(1)

class XTitle:
    def __init__(self, callback):
        self.callback = callback

    async def run(self):
        try:
            await asyncio.to_thread(self.loop)
        except Exception:
            raise Exception(f"xtitle thread failed")

    def loop(self):
        popen = subprocess.Popen(["xtitle", "-s"],
                                 stdout=subprocess.PIPE,
                                 universal_newlines=True)
        for line in iter(popen.stdout.readline, ""):
            self.callback(line.strip())
        popen.stdout.close()
        code = popen.wait()
        if code != 0:
            raise Exception(f"xtitle exited with code {code}")

def item(period=0):
    """A decorator to simplify defining periodic functions"""
    def decorate(func):
        def wrapper(*args, **kwargs):
            if "period" in args:
                return period
            elif "name" in args:
                return func.__name__
            else:
                return func(*args, **kwargs)
        return wrapper
    return decorate

class BarBase:
    def __init__(self, use_ascii=False, items=None, out=sys.stdout):
        self.server = None
        self.ws_str = None # to be set from wsw
        self.a = use_ascii
        self.out = out
        self.wm = WM(self.run_wm_items)
        self.xtitle = XTitle(self.run_xtitle_items)

        if items is None:
            self.items_str = default_items
        else:
            self.items_str = items

        places = re.split(r"\s*\|\s*", self.items_str)

        self.items_map = {"l": [], "c": [], "r": []}
        for i in range(len(places)):
            place = [getattr(self, m)
                     for m in re.split(r"\s+", places[i]) if m]
            if i == 0:
                self.items_map["l"] += place
            elif i == 1:
                self.items_map["c"] += place
            else:
                self.items_map["r"] += place

        self.items = self.items_map["l"] + \
            self.items_map["c"] + \
            self.items_map["r"]

        self.last = {}
        self.running = False
        self.coroutines = []
        self.tasks = None

    def print_items(self):
        for i in self.items:
            print(i("name"), i("period"))

    def render(self):
        out = ""

        if self.a:
            items_out = []
            for item in self.items:
                content = self.last[item("name")]
                if not content: continue
                items_out.append(content)
            out += " | ".join(items_out)
        else:
            for place in self.items_map:
                out += f"%{{{place}}}"
                items_out = []
                for item in self.items_map[place]:
                    content = self.last[item("name")]
                    if not content: continue
                    items_out.append(content)
                out += "  ".join(items_out)
            out += " "

        self.out.write(out + "\n")
        try:
            self.out.flush()
        except BrokenPipeError:
            exit(0)

    def run_item(self, item):
        if item in self.items:
            self.last[item("name")] = item()

    async def run_periodic_item(self, item):
        if item not in self.items:
            return
        while self.running:
            self.run_item(item)
            self.render()
            # print(f">>>>> CALLED {item('name')}, sleeping {item('period')}\n")
            period = item("period")
            if period <= 0:
                break
            await asyncio.sleep(period)

    def run_wm_items(self, ws_str):
        self.ws_str = ws_str
        self.run_item(self.workspaces)
        self.run_item(self.program)
        self.run_item(self.add)
        self.render()

    def run_xtitle_items(self, title):
        self.wm.title = title
        self.run_item(self.program)
        self.render()

    async def handle_connection(self, reader, writer):
        data = b""
        while True:
            tmp = await reader.read(1024)
            data += tmp
            if not tmp: break
        data = data.decode().split("?")
        cmd = data[0]
        data = data[1]
        if cmd == "update":
            item = getattr(self, data)
            self.last[item("name")] = item()
            self.render()

    def init(self):
        for item in self.items:
            self.run_item(item)

    async def run(self):
        if self.running:
            return
        self.running = True
        self.init()
        self.render()
        coroutines = []
        # window manager
        if self.wm is not None:
            coroutines.append(self.wm.run())
        # xtitle
        if self.xtitle is not None:
            coroutines.append(self.xtitle.run())
        # periodic items
        for item in self.items:
            if item("period") > 0:
                coroutines.append(self.run_periodic_item(item))
        # server
        server = await asyncio.start_server(
            self.handle_connection, "localhost", 0)
        port = server.sockets[0].getsockname()[1]
        with open(port_file, "w") as f:
            f.write(str(port))
        coroutines.append(server.serve_forever())
        self.tasks = asyncio.gather(*coroutines)
        try:
            await self.tasks
        except asyncio.CancelledError:
            pass

    def stop(self):
        self.running = False
        self.tasks.cancel()

class Bar(BarBase):

    @item()
    def workspaces(self):
        if self.wm is None or self.a:
            return None
        else:
            return self.ws_str

    @item()
    def add(self):
        if self.wm is None or self.a or self.wm.title == "":
            return None
        names = list(map(lambda w: w.name, self.wm.impl.workspaces))
        for w in self.wm.nice_workspaces:
            if w not in names:
                onclick = f"{self.wm.impl.workspace_cmd} '{w}' >/dev/null"
                return f"%{{A:{onclick}:}}%{{A}}"
        return None

    @item()
    def program(self):
        if self.wm is None or self.wm.title is None:
            return None
        # not accurate, depends on the resolution and font size, but too lazy
        if "workspaces" in self.items_str:
            max_title = 50 - len(self.wm.impl.workspaces) * 3
        else:
            max_title = 80
        title = self.wm.title
        if len(title) > max_title:
            title = title[:max_title].strip() + "…"
        if use_arabic:
            title = bidi.algorithm.get_display(
                arabic_reshaper.reshape(title))
        if self.a:
            return title
        else:
            out = ""
            if title:
                return "%{A:nice-kill:}%{A}  " + \
                    "%{A:wm-msg program-menu:}" + title + "%{A}"
            else:
                return None

    @item(period=1)
    def clock(self):
        t = datetime.datetime.now().strftime("%a %Y.%m.%d %I:%M:%S %p")
        if self.a:
            return t
        else:
            # cmd = "theterm -a '-c __floatme__ -g 70x35' 'cal -y && read -p \"\"'"
            cmd = "gsimplecal"
            return f"%{{A:{cmd}&:}}{t}%{{A}}"

    @item(period=3)
    def battery(self):
        try:
            acpi = sh.grep(sh.acpi("-b"), v="unavailable").split("\n")[0]
            percent = int(acpi.split(", ")[1].replace("%", ""))
            charging = "Charging" in acpi
        except:
            return None

        if self.a:
            charging = "~" if charging else ""
            return f"b{charging}{percent}%"
        else:
            out = ""
            r = "-"

            if charging:
                r = '#FFFFFF' if percent >= 99 else '#FFD700'
                out += " "
            elif percent <= 20:
                if percent > 10:
                    r = '#FF0000'
                else:
                    r = '#000000'
                if percent <= 15:
                    out += " "

            if percent < 50:
                out += ""
            elif percent < 60:
                out += ""
            elif percent < 90:
                out += ""
            else:
                out += ""

            out += f" {percent}%%"

            if percent <= 10 and not charging:
                msg = "%{B#FF0000} "
                if percent <= 5:
                    msg += "HELP "
                    # sh.systemctl("poweroff") # TODO: add countdown
                elif percent <= 7:
                    msg += "EXTREMELY LOW "
                elif percent <= 10:
                    msg += "LOW BATTERY "
                out = msg + out + " %{B-}"

            cmd = "theterm -a '-c __floatme__ -g 75x3' 'watch -tn 1 acpi -i'"
            out = f"%{{F{r}}}%{{A:{cmd}&:}}{out}%{{A}}%{{F-}}"

            return out

    @item(period=5)
    def wifi(self):
        try:
            with open("/proc/net/wireless") as f:
                v = re.split(r"\s+", f.read().split("\n")[2])[2]
                v = int(float(v))
                if self.a:
                    return f"s{v}%"
                else:
                    return f"%{{A:networkmanager_dmenu&:}} {v}%%%{{A}}"
        except:
            pass
        return None

    @item()
    def lang(self):
        try:
            out = sh.lang().strip()
        except:
            return None
        if self.a:
            return out
        else:
            return f"%{{A:lang tog:}}{out}%{{A}}"

    @item(period=30)
    def pray(self):
        out = os.popen("prayer --mini 2>/dev/null").read().strip()
        if not out:
            return None
        if self.a:
            return f"p{out}"
        else:
            cmd = "theterm -a '-c __floatme__ -g 25x8' 'prayer && read -p \"\"'"
            return f"%{{A:{cmd}&:}}  {out}%{{A}}"

    @item(period=30 * 60)
    def weather(self):
        fpath = f"{HOME}/.cache/weatherreport"
        # try:
        #     sh.curl("-s", "wttr.in?n", _out=fpath)
        # except:
        #     pass
        if not os.path.exists(fpath):
            return None

        with open(fpath, "rb") as f:
            try:
                out = f.read().decode(errors="ignore").split("\n")[3] # third line
            except:
                return None
            # remove colors https://stackoverflow.com/a/14693789/3825872
            r = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
            out = r.sub("", out).strip()
            try:
                temp = re.search(".+ (.+) °C.*", out).group(1)
            except:
                return None
            try:
                temp = re.search(".+\((\d+)\)", temp).group(1)
            except:
                pass
            out = f"{temp}°C"

            if self.a:
                return f"w{out}"
            else:
                cmd = f"theterm -a '-c __floatme__ -g 63x18' 'less --mouse -R {fpath}'"
                return f"%{{A:{cmd}&:}}  {out}%{{A}}"

        return None

    @item(period=5)
    def temperature(self):
        try:
            o = json.loads(sh.sensors("coretemp-isa-0000", "-j").strip()) \
                ["coretemp-isa-0000"]["Package id 0"]
            t = float(o["temp1_input"])
            m = float(o["temp1_max"])
        except:
            return None

        percent = int((t / m) * 100)
        if percent < 70:
            return None

        if self.a:
            return f"t{int(t)}°C"
        else:
            out = ""
            if percent > 90:
                out += "%{F#FF0000} "
            elif percent > 50:
                out += ""
            elif percent > 40:
                out += ""
            else:
                out += ""
            out += f"%{{F-}} {int(t)}°C"
            cmd = "theterm -a '-c __floatme__ -g 65x19' 'watch -tn 1 sensors'"
            return f"%{{A:{cmd}&:}}{out}%{{A}}"

    @item()
    def start(self):
        return "%{A:menus&:} START%{A}" if not self.a else None

    @item()
    def power(self):
        return "%{A:menus power&:}%{A}" if not self.a else None

    @item()
    def systray(self):
        return "%{A:toggle-systray&:}%{A}" if not self.a else None

    @item()
    def donno(self):
        return "%{A:theterm 'lolcowforune -p'&:}¯\_(ツ)_/¯%{A}" \
            if not self.a else None

    @item()
    def host(self):
        return os.uname()[1]

def lemonbar():
    monitors = [o for o in xrandr.parse() if o["connected"] and o["geometry"]]

    fonts = []
    f = os.getenv("FONT")
    if f:
        fonts += ["-f", f]
    fonts += [
        # "-f", "Kawkab Mono:pixelsize=12",
        "-f", "Source Han Sans CN",
        "-f", "DejaVu Sans Mono",
        "-f", "Font Awesome 5 Free Solid:pixelsize=19",
        "-f", "Hack Nerd Font"
    ]

    args = ["lemonbar", "-B", background, "-F", foreground,
            "-a", "30"] + fonts

    lemons = []
    for mon in monitors:
        g = mon["geometry"]
        lemonp = subprocess.Popen(args + ["-g", f"{g['w']}x+{g['x']}+{g['y']}"],
                                  stdin=subprocess.PIPE,
                                  stdout=subprocess.PIPE,
                                  universal_newlines=True)
        lemons.append(lemonp)

        bar = Bar(items=None, out=lemonp.stdin)
        signal.signal(signal.SIGINT, lambda signal, frame: bar.stop())

        def lemon_output_handler():
            for line in iter(lemonp.stdout.readline, ""):
                os.system(line.strip())
            lemonp.stdout.close()

        threading.Thread(target=lambda: asyncio.run(bar.run())).start()
        threading.Thread(target=lemon_output_handler).start()

    for l in lemons:
        l.wait()

async def main():
    if len(argv) >= 2 and argv[1] == "foobar":
        print([o for o in xrandr.parse() if o["connected"]])
    elif len(argv) >= 2 and argv[1] == "lemon":
        lemonbar()
    elif len(argv) >= 3 and argv[1] == "update":
        item = argv[2].encode()
        with open(port_file, "r") as f:
            try:
                port = int(f.read())
                reader, writer = await asyncio.open_connection("localhost", port)
                writer.write(b"update?" + item)
                writer.close()
            except:
                print("Error finding socket port")
    else:
        a = False # ascii
        p = False # persistent
        items = None

        if len(argv) >= 2 and argv[1] == "-a":
            a = True
            del argv[1]

        if len(argv) >= 2 and argv[1] == "-p":
            p = True
            del argv[1]

        if len(argv) >= 2 and argv[1]:
            items = argv[1]

        bar = Bar(use_ascii=a, items=items)
        if p:
            signal.signal(signal.SIGINT, lambda signal, frame: bar.stop())
            await bar.run()
        else:
            bar.init()
            bar.render()

if __name__ == "__main__":
    asyncio.run(main())
