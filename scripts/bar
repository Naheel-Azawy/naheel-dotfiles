#!/bin/python3

from pythonish import *
import os
import sys
import json
import re
import time
import datetime
import threading
import subprocess
import socket
import signal

background = '#ff000000'
foreground = '#ffffff'

default_items = "start workspaces | clock | systray donno lang pray weather temperature wifi battery power"

port_file = "/tmp/.nbarport"

def primary():
    x = os.popen("xrandr -q").read()
    m = re.search(r"connected primary \d+x\d+(\+\d+)\+\d+ ", x)
    return m.group(1) + "+0"

# example: WM(lambda wm: print(wm.json())).run()
class WM:
    def __init__(self, callback):
        wm = WINDOW_MANAGER
        if wm == "i3":
            self.impl = I3WM(callback)
        elif wm == "bspwm":
            self.impl = BSPWM(callback)
        else:
            raise Exception(f"Unknown window manager {wm}")

    def run(self):
        self.impl.run()

    def title(self):
        return self.impl.title

    def json(self):
        workspaces = {}
        for w in self.impl.workspaces:
            workspaces[w.name] = {
                "visible": w.visible,
                "focused": w.focused,
                "urgent":  w.urgent
            }
        return json.dumps({
            "title": self.impl.title,
            "workspaces": workspaces
        })

    def lemon(self):
        out = ""
        for w in self.impl.workspaces:
            if w.focused:
                out += "%{F#000000 B#ffffff}"
            elif w.visible:
                out += "%{F#ffffff B#333333}"
            elif w.urgent:
                out += "%{F#ffffff B#900000}"
            else:
                out += "%{F#ffffff B-}"
            onclick = f"{self.impl.workspace_cmd} '{w.name}' >/dev/null"
            out += f"%{{A:{onclick}:}} "
            out += w.name
            #.encode(encoding="ascii",errors="backslashreplace").decode()
            out += " %{A}"
        out += "%{F- B-}" # reset the colors
        return out

class WMImpl:
    def __init__(self):
        raise Exception("Unimplemented")

    def run(self):
        raise Exception("Unimplemented")

class Workspace:
    def __init__(self):
        self.name    = ""
        self.visible = False
        self.focused = False
        self.urgent  = False

class I3WM(WMImpl):
    def __init__(self, callback):
        self.callback = callback
        self.title = ""
        self.workspaces = []
        self.workspace_cmd = "i3-msg workspace"

    def update(self):
        j = json.loads(os.popen(
            "i3-msg -t get_workspaces").read())
        workspaces = []
        for item in j:
            w = Workspace()
            w.name    = item["name"]
            w.visible = item["visible"]
            w.focused = item["focused"]
            w.urgent  = item["urgent"]
            workspaces.append(w)
        self.workspaces = workspaces

    def run(self):
        self.update()
        self.callback(self)
        popen = subprocess.Popen(["i3-msg", "-t", "subscribe", "-m",
                                  '[ "workspace", "window" ]'],
                                 stdout=subprocess.PIPE,
                                 universal_newlines=True)
        for line in iter(popen.stdout.readline, ""):
            msg = json.loads(line)
            # workspace events
            try:
                workspace_event = msg["current"]["type"] == "workspace"
                if workspace_event:
                    self.update()
            except KeyError:
                workspace_event = False
            self.callback(self)
        popen.stdout.close()
        code = popen.wait()
        if code != 0:
            raise Exception(f"i3-msg exited with code {code}")

class BSPWM(WMImpl):
    def __init__(self, callback):
        self.callback = callback
        self.title = ""
        self.workspaces = []
        self.workspace_cmd = "bspc desktop -f"

    def run(self):
        popen = subprocess.Popen(["bspc", "subscribe", "report"],
                                 stdout=subprocess.PIPE,
                                 universal_newlines=True)
        for line in iter(popen.stdout.readline, ""):
            # check man bspc, REPORT FORMAT
            workspaces = []
            focused_monitor = False
            for item in line.split(":"):
                if item[0] == "W":
                    item = item[1:]
                if item[0] in ["M", "m"]:
                    focused_monitor = item[0] == "M"
                elif item[0] in ["O","o","F","U","u"]:
                    w = Workspace()
                    w.name    = item[1:]
                    w.visible = item[0] in ["O", "F"]
                    w.focused = w.visible and focused_monitor
                    w.urgent  = item[0] in ["U", "u"]
                    workspaces.append(w)
            self.workspaces = workspaces
            self.callback(self)
        popen.stdout.close()
        code = popen.wait()
        if code != 0:
            raise Exception(f"bspc exited with code {code}")

def item(period=0):
    """A decorator to simplify defining periodic functions"""
    def decorate(func):
        def wrapper(*args, **kwargs):
            if "period" in args:
                return period
            elif "name" in args:
                return func.__name__
            else:
                return func(*args, **kwargs)
        return wrapper
    return decorate

class Bar:
    def __init__(self, use_ascii=False, items=None):
        self.server = None
        self.a = use_ascii
        self.wm = WM(self.run_wm_items)

        if items is None:
            self.items_str = default_items
        else:
            self.items_str = items

        places = re.split(r"\s*\|\s*", self.items_str)

        self.items_map = {"l": [], "c": [], "r": []}
        for i in range(len(places)):
            place = [getattr(self, m)
                     for m in re.split(r"\s+", places[i]) if m]
            if i == 0:
                self.items_map["l"] += place
            elif i == 1:
                self.items_map["c"] += place
            else:
                self.items_map["r"] += place

        self.items = self.items_map["l"] + \
            self.items_map["c"] + \
            self.items_map["r"]

        # for i in self.items:
        #     print(i("name"), i("period"))
        # print()

        self.last = {}
        self.running = False
        self.threads = []

    @item()
    def workspaces(self):
        return self.wm.lemon() if not self.a else None

    @item()
    def program(self):
        try:
            win_id = sh.xdotool("getactivewindow").strip()
            prop = sh.xprop("-id", win_id).strip()
            match = re.search('.*WM_NAME\(UTF8_STRING\) = "(.+)"', prop)
            if not match: return None
            title = match.group(1)
            cmd = None
            if title.endswith("theterm"):
                try:
                    pid = sh.theterm("--good-pid").strip()
                    cmd = sh.ps("-p", pid, "-o", "command", "-h").strip()
                except:
                    pass
            if cmd:
                title = cmd

            if len(title) > 40:
                title = title[:40] + "..."

            if self.a:
                return title
            else:
                out = ""
                if title:
                    out += "%{A:i3-msg kill >/dev/null:}%{A} "
                out += title
                return out
        except:
            return None

    @item(period=1)
    def clock(self):
        t = datetime.datetime.now().strftime("%a %Y.%m.%d %I:%M:%S %p")
        if self.a:
            return t
        else:
            cmd = "theterm -a '-c __floatme__ -g 70x35' 'cal -y && read -p \"\"'"
            return f"%{{A:{cmd}&:}}{t}%{{A}}"

    @item(period=3)
    def battery(self):
        acpi = os.popen("acpi -b").read().strip()
        percent = int(acpi.split(", ")[1].replace("%", ""))
        charging = "Discharging" not in acpi

        if self.a:
            charging = "~" if charging else ""
            return f"b{charging}{percent}%"
        else:
            out = ""
            r = "-"

            if charging:
                r = '#FFFFFF' if percent >= 99 else '#FFD700'
                out += f"%{{F{r}}} "
            elif percent <= 20:
                r = '#FF0000'
                out += f"%{{F{r}}}"
                if percent <= 15:
                    out += " "

            if percent < 50:
                out += ""
            elif percent < 60:
                out += ""
            elif percent < 90:
                out += ""
            else:
                out += ""

            out += f"%{{F-}} {percent}%"
            cmd = "theterm -a '-c __floatme__ -g 75x3' 'watch -tn 1 acpi -i'"
            out = f"%{{A:{cmd}:}}{out}%{{A}}"

            def notif(msg):
                os.system(f"dunstify -u critical -r 12345 '{msg}'")

            if not charging:
                if percent <= 5:
                    notif("SHUTTING DOWN!")
                    os.system("systemctl poweroff")
                elif percent <= 7:
                    notif(f"VERY LOW BATTERY {percent}% WILL SHUTDOWN AT 5%!!!")
                elif percent < 10:
                    notif(f"LOW BATTERY {percent}%")

            return out

    @item(period=5)
    def wifi(self):
        try:
            with open("/proc/net/wireless") as f:
                v = re.split(r"\s+", f.read().split("\n")[2])[2]
                v = int(float(v))
                if self.a:
                    return f"s{v}%"
                else:
                    return f"%{{A:networkmanager_dmenu&:}} {v}%%{{A}}"
        except:
            pass
        return None

    @item()
    def lang(self):
        out = os.popen("lang").read().strip()
        if self.a:
            return out
        else:
            return f"%{{A:lang tog:}}{out}%{{A}}"

    @item(period=30)
    def pray(self):
        out = os.popen("theprayer n 2>/dev/null").read().strip()
        if not out:
            return None
        if self.a:
            return f"p{out}"
        else:
            cmd = "theterm -a '-c __floatme__ -g 25x8' 'theprayer && read -p \"\"'"
            return f"%{{A:{cmd}&:}}  {out}%{{A}}"

    @item(period=30 * 60)
    def weather(self):
        f = f"{HOME}/.cache/weatherreport"
        if not os.path.exists(f):
            return None

        with open(f, "rb") as f:
            out = f.read().decode(errors="ignore") \
                          .split("\n")[3] # third line
            # remove colors https://stackoverflow.com/a/14693789/3825872
            r = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
            out = r.sub("", out).strip()
            s = re.search(".+[ \.](\d+) °C", out) # extract the temperature
            try:
                out = f"{s.group(1)}°C"
            except:
                return None

            if self.a:
                return f"w{out}"
            else:
                cmd = "theterm -a '-c __floatme__ -g 63x38' 'weather-update & head -n 37 ~/.cache/weatherreport && read -p \"\"'"
                return f"%{{A:{cmd}&:}}  {out}%{{A}}"

        return None

    @item(period=5)
    def temperature(self):
        o = json.loads(os.popen(f"sensors coretemp-isa-0000 -j").read()) \
            ["coretemp-isa-0000"]["Package id 0"]
        t = float(o["temp1_input"])
        m = float(o["temp1_max"])

        percent = int((t / m) * 100)
        if percent < 70:
            return None

        if self.a:
            return f"t{int(t)}°C"
        else:
            out = ""
            if percent > 90:
                out += "%{F#FF0000} "
            elif percent > 50:
                out += ""
            elif percent > 40:
                out += ""
            else:
                out += ""
            out += f"%{{F-}} {int(t)}°C"
            cmd = "theterm -a '-c __floatme__ -g 65x19' 'watch -tn 1 sensors'"
            return f"%{{A:{cmd}&:}}{out}%{{A}}"

    @item()
    def start(self):
        return "%{A:dmenulauncher&:} START%{A}" if not self.a else None

    @item()
    def close(self):
        return "%{A:i3-msg kill >/dev/null:}%{A}" if not self.a else None

    @item()
    def power(self):
        return "%{A:dmenupower:}%{A}" if not self.a else None

    @item()
    def systray(self):
        return "%{A:toggle-systray&:}%{A}" if not self.a else None

    @item()
    def donno(self):
        return "%{A:theterm 'lolcowforune -p'&:}¯\_(ツ)_/¯%{A}" \
            if not self.a else None

    @item()
    def host(self):
        return os.uname()[1]

    def start_thread(self, func):
        def wrapper():
            try:
                func()
            except Exception as e:
                print(e)
        t = threading.Thread(target=wrapper)
        self.threads.append(t)
        t.start()

    def render(self):
        out = ""

        if self.a:
            items_out = []
            for item in self.items:
                content = self.last[item("name")]
                if not content: continue
                items_out.append(content)
            out += " | ".join(items_out)
        else:
            for place in self.items_map:
                out += f"%{{{place}}}"
                items_out = []
                for item in self.items_map[place]:
                    content = self.last[item("name")]
                    if not content: continue
                    items_out.append(content)
                out += "  ".join(items_out)
            out += " "

        print(out)
        try:
            sys.stdout.flush()
        except BrokenPipeError:
            exit()

    def run_and_sleep(self, item):
        if item not in self.items:
            return

        while self.running:
            self.last[item("name")] = item()
            self.render()
            # print(f">>>>> CALLED {item('name')}, sleeping {item('period')}\n")
            period = item("period")
            if period <= 0:
                break
            time.sleep(period)

    def run_wm_items(self, wm):
        self.run_and_sleep(self.workspaces)
        self.run_and_sleep(self.program)

    def init(self):
        for item in self.items:
            self.last[item("name")] = item()

    def run(self):
        self.running = True
        self.init()
        self.render()
        self.start_thread(self.wm.run)
        for item in self.items:
            if item("period") > 0:
                # periodic items run on their own thread
                self.start_thread(lambda: self.run_and_sleep(item))

        # start server
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind(("localhost", 0))
        port = self.server.getsockname()[1]
        with open(port_file, "w") as f:
            f.write(str(port))
        self.server.listen(1)

        while self.running:
            conn, addr = self.server.accept()

            # recieving data
            data = b""
            while True:
                tmp = conn.recv(1024)
                data += tmp
                if not tmp: break
            data = data.decode().split("?")
            cmd = data[0]
            data = data[1]
            if cmd == "update":
                item = getattr(self, data)
                self.last[item("name")] = item()
                self.render()

        self.server.close()

    def stop(self):
        self.running = False

def lemonbar():
    bin = os.path.abspath(__file__)

    geometry = primary()
    if geometry:
        geometry = f"-g {geometry}"

    fonts = ["Iosevka Fixed",
             "Source Han Sans CN",
             "Font Awesome 5 Free Solid"]
    awesome_size = 19

    tmp = ""
    for f in fonts:
        if "Awesome" in f:
            f += f":pixelsize={awesome_size}"
        tmp += f"-f '{f}' "
    fonts = tmp

    os.system(f"""python3 '{bin}' -p |
    lemonbar {geometry} -p {fonts} -B '{background}' -F '{foreground}' -a 30 |
    sh""")

def on_int(bar):
    bar.stop()
    # for t in b.threads:
    #     t.join()
    exit() # TODO: close threads properly

if __name__ == "__main__":
    args = sys.argv

    if len(args) >= 2 and args[1] == "xrandr":
        print(primary())
    elif len(args) >= 2 and args[1] == "lemon":
        lemonbar()
    elif len(args) >= 3 and args[1] == "update":
        item = args[2].encode()
        with open(port_file, "r") as f:
            try:
                port = int(f.read())
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect(("localhost", port))
                s.send(b"update?" + item)
                s.close()
            except:
                print("Error finding socket port")
    else:
        a = False
        p = False
        items = None

        if len(args) >= 2 and args[1] == "-a":
            a = True
            del args[1]

        if len(args) >= 2 and args[1] == "-p":
            p = True
            del args[1]

        if len(args) >= 2 and args[1]:
            items = args[1]

        b = Bar(use_ascii=a, items=items)
        signal.signal(signal.SIGINT, lambda signal, frame: on_int(b))
        if p:
            b.run()
        else:
            b.init()
            b.render()
